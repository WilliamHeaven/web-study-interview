# 浏览器相关
前面两节是关于性能优化的
## 方法：
- [性能优化](#1-性能优化)
- [跨标签页通讯](#2-跨标签页通讯)
- [浏览器架构](#3-浏览器架构)
- [跨标签页通讯](#4-跨标签页通讯)
- [跨标签页通讯](#5-跨标签页通讯)
- [跨标签页通讯](#6-跨标签页通讯)
- [跨标签页通讯](#7-跨标签页通讯)
## 1.性能优化
### I. 防抖与节流
防抖与节流函数是一种最常用的 高频触发优化方式，能对性能有较大的帮助。
- **防抖**(debounce): 将多次高频操作优化为只在最后一次执行，通常使用的场景是：用户输入，只需再输入完成后做一次输入校验即可。
```
function debounce(fn, wait, immediate) {
    let timer = null

    return function() {
        let args = arguments
        let context = this

        if (immediate && !timer) {
            fn.apply(context, args)
        }

        if (timer) clearTimeout(timer)
        timer = setTimeout(() => {
            fn.apply(context, args)
        }, wait)
    }
}
```
- **节流**(throttle): 每隔一段时间后执行一次，也就是降低频率，将高频操作优化成低频操作，通常使用场景: 滚动条事件 或者 resize 事件，通常每隔 100~500 ms执行一次即可。
```
function throttle(fn, wait, immediate) {
    let timer = null
    let callNow = true
    
    return function() {
        let context = this,
            args = arguments

        if (callNow) {
            fn.apply(context, args)
            callNow = false
        }

        if (!timer) {
            timer = setTimeout(() => {
                fn.apply(context, args)
                timer = null
            }, wait)
        }
    }
}
```
### II.重绘与回流
当元素的样式发生变化时，浏览器需要触发更新，重新绘制元素。这个过程中，有两种类型的操作，即重绘与回流。
- **重绘(repaint)**: 当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要UI层面的重新像素绘制，因此 损耗较少
- **回流(reflow)**: 当元素的尺寸、结构或触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。会触发回流的操作:
    - 页面初次渲染
    - 浏览器窗口大小改变
    - 元素尺寸、位置、内容发生改变

    - 元素字体大小变化
        - 添加或者删除可见的 dom 元素
    - 激活 CSS 伪类（例如：:hover）
    - 查询某些属性或调用某些方法
        ```
        - clientWidth、clientHeight、clientTop、clientLeft
        - offsetWidth、offsetHeight、offsetTop、offsetLeft
        - scrollWidth、scrollHeight、scrollTop、scrollLeft
        - getComputedStyle()
        - getBoundingClientRect()
        - scrollTo()
        ```
**回流必定触发重绘，重绘不一定触发回流。重绘的开销较小，回流的代价较高**
最佳实践:
- css
    - 避免使用`table`布局
    - 将动画效果应用到`position`属性为`absolute`或`fixed`的元素上
- javascript
    - 避免频繁操作样式，可汇总后统一 **一次修改**
    - 尽量使用`class`进行样式修改
    - 减少`dom`的增删次数，可使用 **字符串** 或者 `documentFragment` 一次性插入
    - 极限优化时，修改样式可将其`display: none`后修改
    - 避免多次触发上面提到的那些会触发回流的方法，可以的话尽量用 **变量存住**
## 2. 跨标签页通讯
不同标签页间的通讯，本质原理就是去运用一些可以 **共享的中间介质**，因此比较常用的有以下方法:
- 通过父页面`window.open()`和子页面`postMessage`
    - 异步下，通过 `window.open('about: blank')` 和 `tab.location.href = '*' `
- 设置同域下共享的`localStorage`与监听`window.onstorage`
    - 重复写入相同的值无法触发
    - 会受到浏览器隐身模式等的限制
- 设置共享`cookie`与不断轮询脏检查`(setInterval)`
- 借助服务端或者中间层实现
## 3. 浏览器架构
- 用户界面
- 主进程
- 内核
    - 渲染引擎
    - JS 引擎
        - 执行栈
    - 事件触发线程
        - 消息队列
            - 微任务
            - 宏任务
    - 网络异步线程
    - 定时器线程
## 4. 性能优化
## 5. 性能优化
## 6. 性能优化
## 7. 性能优化
## 8. 性能优化
## 9. 性能优化

