# JavaScript
## 目录
- [原型/构造函数/实例](#1-原型/构造函数/实例)
- [原型链](#2-原型链)
- [执行上下文(EC)](#3-执行上下文(EC))
- [变量对象](#4-变量对象)
- [作用域](#5-作用域)
- [作用域链](#6-作用域链)
- [闭包](#7-闭包)
- [script引入方式](#8-script引入方式)
- [new运算符的执行过程](#9-new运算符的执行过程)
- [instanceof原理](#10-instanceof原理)
- [代码的复用](#11-代码的复用)
- [继承](#12-继承)
- [对象的拷贝](#13-对象的拷贝)
- [作用域链](#14-作用域链)
- [作用域链](#15-作用域链)
- [作用域链](#16-作用域链)
- [作用域链](#17-作用域链)
- [作用域链](#18-作用域链)
- [作用域链](#19-作用域链)
- [作用域链](#20-作用域链)
- [作用域链](#21-作用域链)
- [作用域链](#22-作用域链)
## 1. 原型/构造函数/实例
- **原型**`(prototype)`: 一个简单的对象，用于实现对象的**属性继承**。可以简单的理解成对象的爹。在 Firefox 和 Chrome 中，每个`JavaScript`对象中都包含一个`__proto__ `(非标准)的属性指向它爹(该对象的原型)，可`obj.__proto__`进行访问。
- **构造函数**: 可以通过`new`来 __新建一个对象__ 的函数。
- **实例**: 通过构造函数和`new`创建出来的对象，便是实例。**实例**通过`__proto__`指向**原型**，通过constructor指向**构造函数**。

这里来举个栗子，以Object为例，我们常用的Object便是一个构造函数，因此我们可以通过它构建实例。

```
// 实例
const instance = new Object()
```
则此时， **实例**为`instance`, **构造函数**为`Object`，我们知道，构造函数拥有一个`prototype`的属性指向原型，因此原型为:
```
// 原型
const prototype = Object.prototype
```
这里我们可以来看出三者的关系:
```
实例.__proto__ === 原型

原型.constructor === 构造函数

构造函数.prototype === 原型

实例.constructorr === 构造函数
```
放大来看，我画了张图供大家彻底理解:
![GitHub Logo](/img/原型和原型链.jpg)

## 2. 原型链
**原型链**是由**原型对象**组成，每个对象都有 `__proto__`属性，指向了创建该对象的构造函数的原型，`__proto__` 将对象连接起来组成了原型链。是一个用来**实现继承和共享属性**的有限的对象链。

- **属性查找机制**: 当查找对象的属性时，如果实例对象自身不存在该属性，则沿着原型链往上一级查找，找到时则输出，不存在时，则继续沿着原型链往上一级查找，直至最顶级的原型对象`Object.prototype`，如还是没找到，则输出`undefined`；
- **属性修改机制**: 只会修改实例对象本身的属性，如果不存在，则进行添加该属性，如果需要修改原型的属性时，则可以用: `b.prototype.x = 2`；但是这样会造成所有继承于该对象的实例的属性发生改变。

## 3. 执行上下文(EC)
执行上下文可以简单理解为一个对象:

- 它包含三个部分:
    - 变量对象(VO)
    - 作用域链(词法作用域)
    - `this`指向

- 它的类型:
    - 全局执行上下文
    - 函数执行上下文
    - `eval`执行上下文

- 代码执行过程:
    - 创建 **全局上下文** (global EC)
    - 全局执行上下文 (caller) 逐行 **自上而下** 执行。遇到函数时，**函数执行上下文** (callee) - `push`到执行栈顶层
    - 函数执行上下文被激活，成为 active EC, 开始执行函数中的代码，caller 被挂起
    - 函数执行完后，callee 被`pop`移除出执行栈，控制权交还全局上下文 (caller)，继续执行
## 4. 变量对象
变量对象，是执行上下文中的一部分，可以抽象为一种 **数据作用域**，其实也可以理解为就是一个简单的对象，它存储着该执行上下文中的所有 **变量和函数声明(不包含函数表达式)**。

    活动对象 (AO): 当变量对象所处的上下文为 active EC 时，称为活动对象。
## 5. 作用域
执行上下文中还包含作用域链。理解作用域之前，先介绍下作用域。作用域其实可理解为该上下文中声明的 **变量和声明的作用范围**。可分为 **块级作用域** 和 **函数作用域**

特性:

- **声明提前**: 一个声明在函数体内都是可见的, 函数优先于变量
- 非匿名自执行函数，函数变量为 只读 状态，无法修改
```
const foo = 1
(function foo() {
    foo = 10  // 由于foo在函数中只为可读，因此赋值无效
    console.log(foo)
}()) 

// 结果打印：  ƒ foo() { foo = 10 ; console.log(foo) }
```
## 6. 作用域链
我们知道，我们可以在执行上下文中访问到父级甚至全局的变量，这便是作用域链的功劳。作用域链可以理解为一组对象列表，包含 **父级和自身的变量对象**，因此我们便能通过作用域链访问到父级里声明的变量或者函数。

- 由两部分组成:
    - `[[scope]]`属性: 指向父级变量对象和作用域链，也就是包含了父级的`[[scope]]`和`AO`
    - **AO**: 自身活动对象

如此 `[[scopr]]`包含`[[scope]]`，便自上而下形成一条 **链式作用域**。
## 7. 闭包
闭包属于一种特殊的作用域，称为 **静态作用域**。它的定义可以理解为: **父函数被销毁** 的情况下，返回出的子函数的`[[scope]]`中仍然保留着父级的单变量对象和作用域链，因此可以继续访问到父级的变量对象，这样的函数称为闭包。

- 闭包会产生一个很经典的问题:
    - 多个子函数的`[[scope]]`都是同时指向父级，是完全共享的。因此当父级的变量对象被修改时，所有子函数都受到影响。

- 解决:
    - 变量可以通过 **函数参数的形式** 传入，避免使用默认的`[[scope]]`向上查找
    - 使用`setTimeout`包裹，通过第三个参数传入
    - 使用 **块级作用域**，让变量成为自己上下文的属性，避免共享
## 8. script 引入方式：
- html 静态`<script>`引入
- js 动态插入`<script>`
- `<script defer>`: 异步加载，元素解析完成后执行
- `<script async>`: 异步加载，与元素渲染并行执行
## 9. new运算符的执行过程
- 新生成一个对象
- 链接到原型: `obj.__proto__ = Con.prototype`
- 绑定this: `apply`
- 返回新对象
## 10. instanceof原理
能在实例的 **原型对象链** 中找到该构造函数的`prototype`属性所指向的 **原型对象**，就返回`true`。即:
```
// __proto__: 代表原型对象链
instance.[__proto__...] === instance.constructor.prototype

// return true
```
## 11. 代码的复用
当你发现任何代码开始写第二遍时，就要开始考虑如何复用。一般有以下的方式:
- 函数封装
- 继承
- 复制`extend`
- 混入`mixin`
- 借用`apply/call`
## 12. 继承
在 JS 中，继承通常指的便是 **原型链继承**，也就是通过指定原型，并可以通过原型链继承原型上的属性或者方法。
- 最优化: 圣杯模式 
```
var inherit = (function(c,p){
    var F = function(){};
    return function(c,p){
        F.prototype = p.prototype;
        c.prototype = new F();
        c.uber = p.prototype;
        c.prototype.constructor = c;
    }
})();
```
- 使用 ES6 的语法糖 class / extends 
## 13. 对象的拷贝
- 浅拷贝: 以赋值的形式拷贝引用对象，仍指向同一个地址，修改时原对象也会受到影响
    - Object.assign
    - 展开运算符(...)
- 深拷贝: 完全拷贝一个新对象，修改时原对象不再受到任何影响
    - JSON.parse(JSON.stringify(obj)): 性能最快
        - 具有循环引用的对象时，报错
        - 当值为函数或undefined时，无法拷贝
    - 递归进行逐一赋值

## 14. new运算符的执行过程
## 15. new运算符的执行过程
## 16. new运算符的执行过程
## 17. new运算符的执行过程
## 18. new运算符的执行过程
## 19. new运算符的执行过程